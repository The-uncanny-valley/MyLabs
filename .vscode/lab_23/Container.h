// Container.h
// Если макрос CONTAINER_H ещё не определён — продолжить компиляцию этого файла
#ifndef CONTAINER_H // include guard
#define CONTAINER_H

#include <iostream> // стандартная библиотека ввода-вывода

class Set {
private: // доступ только внутри самого класса
    int* data; // указатель на массив динамический int
    int size; // количество элементов в массиве
    int capacity; // вместимость массива

    void resize(); // объявление приватного метода класса (без реализации)
    bool contains(int value) const; // объявление метода, который проверяет наличие элемента

// публичные специальные методы класса Set управляют жизненным циклом объекта
public: // доступно извне класса
    Set(); // конструктор по умолчанию создаёт новый пустой объект Set
    Set(const Set& other); // конструктор копирования
    ~Set(); // деструктор
    Set& operator=(const Set& other); // объявление оператора присваивания (копирующего)

    // The Rule of Three

    // нужно реализовать вручную
    // Если использовать дефолтный (= поверхностный) оператор: Указатели data в a и b будут указывать на одну и ту же область памяти

    int& operator[](int index); // перегрузка оператора [] позволяет обращаться к элементам множества как к массиву
    bool operator==(const Set& other) const; //  перегрузка оператора сравнения ==, позволяющая сравнивать два множества Set как обычные переменные.
    bool operator>(int value) const; // перегрузка оператора >, которая здесь используется не в обычном смысле (больше), а как "проверка принадлежности элемента множеству".
    Set operator-(int n) const; //  перегрузка оператора >, котор используется в смысле "проверка принадлежности элемента множеству".

    void add(int value); // метод для добавления элемента в множество
    void print() const; // метод класса, предназначенный для печати содержимого множества в консоль

    friend std::ostream& operator<<(std::ostream& os, const Set& set); // перегрузку оператора << для вывода множества в поток
    friend std::istream& operator>>(std::istream& is, Set& set); // перегрузка оператора ввода >> для считывания данных в объект


    //  вложенный класс Iterator внутри Set реализует итератор — специальный объект для последовательного доступа к элементам множества.
    class Iterator {
    private:
        const Set& set; //  ссылка на множество Set
        int pos; // текущая позиция итератора в массиве
    public: // методы ниже доступны вне класса
        Iterator(const Set& s); // конструктор итератора принимает ссылку на множество
        void moveLeft(int n); // метод «переместиться влево» сдвигает позицию pos на n шагов назад
        int current() const; // возвращает значение текущего элемента
    };
};

#endif // CONTAINER_H
